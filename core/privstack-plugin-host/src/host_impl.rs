//! Host function implementations for the Wasm Component Model imports.
//!
//! Each WIT import interface maps to a trait generated by `wasmtime::component::bindgen!`.
//! With `trappable_imports: true`, all methods return `wasmtime::Result<T>`.

use crate::bindings::privstack::plugin::*;
use crate::permissions::Permission;
use crate::sandbox::PluginState;
use privstack_model::Entity;
use tracing::{debug, error, info, warn};

// types::Host is an empty marker trait generated by wasmtime bindgen
impl types::Host for PluginState {}

// ============================================================
// sdk::Host — Core CRUD operations (Tier 1, always granted)
// ============================================================

impl sdk::Host for PluginState {
    fn send(&mut self, message: types::SdkMessage) -> wasmtime::Result<types::SdkResponse> {
        let entity_type = &message.entity_type;

        if !self.declared_entity_types.contains(entity_type) {
            warn!(
                plugin_id = %self.plugin_id,
                entity_type = %entity_type,
                "Entity type access denied"
            );
            return Ok(types::SdkResponse {
                success: false,
                error_code: Some(403),
                error_message: Some(format!(
                    "plugin '{}' has not declared entity type '{}'",
                    self.plugin_id, entity_type
                )),
                data: None,
            });
        }

        debug!(
            plugin_id = %self.plugin_id,
            action = ?message.action,
            entity_type = %entity_type,
            "SDK send"
        );

        Ok(match message.action {
            types::SdkAction::Create => self.handle_create(entity_type, message.payload.as_deref()),
            types::SdkAction::Read => self.handle_read(message.entity_id.as_deref()),
            types::SdkAction::Update => self.handle_update(
                entity_type,
                message.entity_id.as_deref(),
                message.payload.as_deref(),
            ),
            types::SdkAction::Delete => self.handle_delete(message.entity_id.as_deref()),
            types::SdkAction::ListAll => self.handle_list(entity_type),
            types::SdkAction::Query => self.handle_query(
                entity_type,
                message.payload.as_deref(),
                &message.parameters,
            ),
            types::SdkAction::Trash => self.handle_trash(message.entity_id.as_deref()),
            types::SdkAction::Restore => self.handle_restore(message.entity_id.as_deref()),
            types::SdkAction::Link => self.handle_link(
                entity_type,
                message.entity_id.as_deref(),
                message.payload.as_deref(),
            ),
            types::SdkAction::Unlink => self.handle_unlink(
                entity_type,
                message.entity_id.as_deref(),
                message.payload.as_deref(),
            ),
            types::SdkAction::GetLinks => self.handle_get_links(
                entity_type,
                message.entity_id.as_deref(),
            ),
            _ => types::SdkResponse {
                success: false,
                error_code: Some(501),
                error_message: Some(format!("action {:?} not yet implemented", message.action)),
                data: None,
            },
        })
    }

    fn search(
        &mut self,
        query: String,
        entity_types: Option<Vec<String>>,
        limit: u32,
    ) -> wasmtime::Result<types::SdkResponse> {
        if let Some(ref types_filter) = entity_types {
            for et in types_filter {
                if !self.declared_entity_types.contains(et) {
                    return Ok(types::SdkResponse {
                        success: false,
                        error_code: Some(403),
                        error_message: Some(format!(
                            "plugin '{}' cannot search entity type '{}'",
                            self.plugin_id, et
                        )),
                        data: None,
                    });
                }
            }
        }

        let types_refs: Option<Vec<&str>> = entity_types
            .as_ref()
            .map(|v| v.iter().map(|s| s.as_str()).collect());

        Ok(match self
            .entity_store
            .search(&query, types_refs.as_deref(), limit as usize)
        {
            Ok(results) => {
                let json = serde_json::to_string(&results).unwrap_or_else(|_| "[]".into());
                types::SdkResponse {
                    success: true,
                    error_code: None,
                    error_message: None,
                    data: Some(json),
                }
            }
            Err(e) => types::SdkResponse {
                success: false,
                error_code: Some(500),
                error_message: Some(e.to_string()),
                data: None,
            },
        })
    }
}

impl PluginState {
    fn handle_create(&self, entity_type: &str, payload: Option<&str>) -> types::SdkResponse {
        let payload = match payload {
            Some(p) => p,
            None => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some("create requires payload".into()),
                    data: None,
                }
            }
        };

        let data: serde_json::Value = match serde_json::from_str(payload) {
            Ok(v) => v,
            Err(e) => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some(format!("invalid JSON payload: {}", e)),
                    data: None,
                }
            }
        };

        let now = chrono::Utc::now().timestamp();
        let id = uuid::Uuid::new_v4().to_string();
        let entity = Entity {
            id: id.clone(),
            entity_type: entity_type.to_string(),
            data,
            created_at: now,
            modified_at: now,
            created_by: self.plugin_id.clone(),
        };

        match self.entity_store.save_entity_raw(&entity) {
            Ok(()) => {
                let result = serde_json::json!({ "id": id });
                types::SdkResponse {
                    success: true,
                    error_code: None,
                    error_message: None,
                    data: Some(result.to_string()),
                }
            }
            Err(e) => types::SdkResponse {
                success: false,
                error_code: Some(500),
                error_message: Some(e.to_string()),
                data: None,
            },
        }
    }

    fn handle_read(&self, entity_id: Option<&str>) -> types::SdkResponse {
        let id = match entity_id {
            Some(id) => id,
            None => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some("read requires entity_id".into()),
                    data: None,
                }
            }
        };

        match self.entity_store.get_entity(id) {
            Ok(Some(entity)) => {
                let json = serde_json::to_string(&entity).unwrap_or_else(|_| "{}".into());
                types::SdkResponse {
                    success: true,
                    error_code: None,
                    error_message: None,
                    data: Some(json),
                }
            }
            Ok(None) => types::SdkResponse {
                success: false,
                error_code: Some(404),
                error_message: Some("not found".into()),
                data: None,
            },
            Err(e) => types::SdkResponse {
                success: false,
                error_code: Some(500),
                error_message: Some(e.to_string()),
                data: None,
            },
        }
    }

    fn handle_update(
        &self,
        entity_type: &str,
        entity_id: Option<&str>,
        payload: Option<&str>,
    ) -> types::SdkResponse {
        let id = match entity_id {
            Some(id) => id,
            None => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some("update requires entity_id".into()),
                    data: None,
                }
            }
        };
        let payload = match payload {
            Some(p) => p,
            None => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some("update requires payload".into()),
                    data: None,
                }
            }
        };

        let data: serde_json::Value = match serde_json::from_str(payload) {
            Ok(v) => v,
            Err(e) => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some(format!("invalid JSON payload: {}", e)),
                    data: None,
                }
            }
        };

        let now = chrono::Utc::now().timestamp();

        // Merge update payload into existing entity to preserve unchanged fields
        let entity = match self.entity_store.get_entity(id) {
            Ok(Some(mut existing)) => {
                match (existing.data.as_object_mut(), data) {
                    (Some(base), serde_json::Value::Object(updates)) => {
                        for (k, v) in updates {
                            base.insert(k, v);
                        }
                    }
                    (_, replacement) => {
                        existing.data = replacement;
                    }
                }
                existing.modified_at = now;
                existing
            }
            _ => {
                // Entity doesn't exist — create new (backwards-compatible)
                Entity {
                    id: id.to_string(),
                    entity_type: entity_type.to_string(),
                    data,
                    created_at: now,
                    modified_at: now,
                    created_by: self.plugin_id.clone(),
                }
            }
        };

        match self.entity_store.save_entity_raw(&entity) {
            Ok(()) => types::SdkResponse {
                success: true,
                error_code: None,
                error_message: None,
                data: None,
            },
            Err(e) => types::SdkResponse {
                success: false,
                error_code: Some(500),
                error_message: Some(e.to_string()),
                data: None,
            },
        }
    }

    fn handle_delete(&self, entity_id: Option<&str>) -> types::SdkResponse {
        let id = match entity_id {
            Some(id) => id,
            None => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some("delete requires entity_id".into()),
                    data: None,
                }
            }
        };

        match self.entity_store.delete_entity(id) {
            Ok(()) => types::SdkResponse {
                success: true,
                error_code: None,
                error_message: None,
                data: None,
            },
            Err(e) => types::SdkResponse {
                success: false,
                error_code: Some(500),
                error_message: Some(e.to_string()),
                data: None,
            },
        }
    }

    fn handle_list(&self, entity_type: &str) -> types::SdkResponse {
        match self
            .entity_store
            .list_entities(entity_type, false, Some(500), None)
        {
            Ok(entities) => {
                let json = serde_json::to_string(&entities).unwrap_or_else(|_| "[]".into());
                types::SdkResponse {
                    success: true,
                    error_code: None,
                    error_message: None,
                    data: Some(json),
                }
            }
            Err(e) => types::SdkResponse {
                success: false,
                error_code: Some(500),
                error_message: Some(e.to_string()),
                data: None,
            },
        }
    }

    fn handle_query(
        &self,
        entity_type: &str,
        _payload: Option<&str>,
        parameters: &[(String, String)],
    ) -> types::SdkResponse {
        let limit = parameters
            .iter()
            .find(|(k, _)| k == "limit")
            .and_then(|(_, v)| v.parse::<usize>().ok())
            .unwrap_or(100);

        let filters: Vec<(String, serde_json::Value)> = parameters
            .iter()
            .filter(|(k, _)| k != "limit")
            .map(|(k, v)| (k.clone(), serde_json::Value::String(v.clone())))
            .collect();

        match self
            .entity_store
            .query_entities(entity_type, &filters, false, Some(limit))
        {
            Ok(entities) => {
                let json = serde_json::to_string(&entities).unwrap_or_else(|_| "[]".into());
                types::SdkResponse {
                    success: true,
                    error_code: None,
                    error_message: None,
                    data: Some(json),
                }
            }
            Err(e) => types::SdkResponse {
                success: false,
                error_code: Some(500),
                error_message: Some(e.to_string()),
                data: None,
            },
        }
    }

    fn handle_trash(&self, entity_id: Option<&str>) -> types::SdkResponse {
        let id = match entity_id {
            Some(id) => id,
            None => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some("trash requires entity_id".into()),
                    data: None,
                }
            }
        };
        match self.entity_store.trash_entity(id) {
            Ok(()) => types::SdkResponse {
                success: true,
                error_code: None,
                error_message: None,
                data: None,
            },
            Err(e) => types::SdkResponse {
                success: false,
                error_code: Some(500),
                error_message: Some(e.to_string()),
                data: None,
            },
        }
    }

    fn handle_restore(&self, entity_id: Option<&str>) -> types::SdkResponse {
        let id = match entity_id {
            Some(id) => id,
            None => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some("restore requires entity_id".into()),
                    data: None,
                }
            }
        };
        match self.entity_store.restore_entity(id) {
            Ok(()) => types::SdkResponse {
                success: true,
                error_code: None,
                error_message: None,
                data: None,
            },
            Err(e) => types::SdkResponse {
                success: false,
                error_code: Some(500),
                error_message: Some(e.to_string()),
                data: None,
            },
        }
    }

    /// Create a link between the source entity (entity_id) and a target specified in the payload.
    /// Payload JSON: `{ "target_type": "note", "target_id": "123", "link_type": "parent" }`
    fn handle_link(
        &self,
        source_type: &str,
        entity_id: Option<&str>,
        payload: Option<&str>,
    ) -> types::SdkResponse {
        let source_id = match entity_id {
            Some(id) => id,
            None => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some("link requires entity_id (source)".into()),
                    data: None,
                }
            }
        };
        let payload = match payload {
            Some(p) => p,
            None => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some("link requires payload with target_type and target_id".into()),
                    data: None,
                }
            }
        };
        let parsed: serde_json::Value = match serde_json::from_str(payload) {
            Ok(v) => v,
            Err(e) => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some(format!("invalid JSON payload: {}", e)),
                    data: None,
                }
            }
        };
        let target_type = parsed
            .get("target_type")
            .and_then(|v| v.as_str())
            .unwrap_or(source_type);
        let target_id = match parsed.get("target_id").and_then(|v| v.as_str()) {
            Some(id) => id,
            None => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some("payload must contain target_id".into()),
                    data: None,
                }
            }
        };

        debug!(
            plugin_id = %self.plugin_id,
            source_type, source_id, target_type, target_id,
            "Creating entity link"
        );

        match self
            .entity_store
            .save_link(source_type, source_id, target_type, target_id)
        {
            Ok(()) => types::SdkResponse {
                success: true,
                error_code: None,
                error_message: None,
                data: None,
            },
            Err(e) => types::SdkResponse {
                success: false,
                error_code: Some(500),
                error_message: Some(e.to_string()),
                data: None,
            },
        }
    }

    /// Remove a link between the source entity (entity_id) and a target specified in the payload.
    fn handle_unlink(
        &self,
        source_type: &str,
        entity_id: Option<&str>,
        payload: Option<&str>,
    ) -> types::SdkResponse {
        let source_id = match entity_id {
            Some(id) => id,
            None => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some("unlink requires entity_id (source)".into()),
                    data: None,
                }
            }
        };
        let payload = match payload {
            Some(p) => p,
            None => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some("unlink requires payload with target_type and target_id".into()),
                    data: None,
                }
            }
        };
        let parsed: serde_json::Value = match serde_json::from_str(payload) {
            Ok(v) => v,
            Err(e) => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some(format!("invalid JSON payload: {}", e)),
                    data: None,
                }
            }
        };
        let target_type = parsed
            .get("target_type")
            .and_then(|v| v.as_str())
            .unwrap_or(source_type);
        let target_id = match parsed.get("target_id").and_then(|v| v.as_str()) {
            Some(id) => id,
            None => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some("payload must contain target_id".into()),
                    data: None,
                }
            }
        };

        debug!(
            plugin_id = %self.plugin_id,
            source_type, source_id, target_type, target_id,
            "Removing entity link"
        );

        match self
            .entity_store
            .remove_link(source_type, source_id, target_type, target_id)
        {
            Ok(()) => types::SdkResponse {
                success: true,
                error_code: None,
                error_message: None,
                data: None,
            },
            Err(e) => types::SdkResponse {
                success: false,
                error_code: Some(500),
                error_message: Some(e.to_string()),
                data: None,
            },
        }
    }

    /// Get all links for an entity (both outgoing and incoming).
    /// Returns a JSON array of link objects with source/target info and titles.
    fn handle_get_links(
        &self,
        entity_type: &str,
        entity_id: Option<&str>,
    ) -> types::SdkResponse {
        let id = match entity_id {
            Some(id) => id,
            None => {
                return types::SdkResponse {
                    success: false,
                    error_code: Some(400),
                    error_message: Some("get-links requires entity_id".into()),
                    data: None,
                }
            }
        };

        // Collect outgoing + incoming links
        let mut links: Vec<serde_json::Value> = Vec::new();

        // Outgoing: source is this entity
        if let Ok(outgoing) = self.entity_store.get_links_from(entity_type, id) {
            for (target_type, target_id) in outgoing {
                let entity = self.entity_store.get_entity(&target_id).ok().flatten();
                let title = entity
                    .as_ref()
                    .and_then(|e| e.data.get("title").and_then(|v| v.as_str()).map(|s| s.to_string()))
                    .unwrap_or_else(|| "Untitled".to_string());
                let icon = entity
                    .as_ref()
                    .and_then(|e| e.data.get("icon").and_then(|v| v.as_str()).map(|s| s.to_string()));

                links.push(serde_json::json!({
                    "source_id": id,
                    "source_type": entity_type,
                    "target_id": target_id,
                    "target_type": target_type,
                    "target_title": title,
                    "link_type": target_type,
                    "icon": icon,
                    "direction": "outgoing",
                }));
            }
        }

        // Incoming: target is this entity
        if let Ok(incoming) = self.entity_store.get_links_to(entity_type, id) {
            for (source_type, source_id) in incoming {
                let entity = self.entity_store.get_entity(&source_id).ok().flatten();
                let title = entity
                    .as_ref()
                    .and_then(|e| e.data.get("title").and_then(|v| v.as_str()).map(|s| s.to_string()))
                    .unwrap_or_else(|| "Untitled".to_string());
                let icon = entity
                    .as_ref()
                    .and_then(|e| e.data.get("icon").and_then(|v| v.as_str()).map(|s| s.to_string()));

                links.push(serde_json::json!({
                    "source_id": source_id,
                    "source_type": source_type,
                    "target_id": id,
                    "target_type": entity_type,
                    "source_title": title,
                    "link_type": source_type,
                    "icon": icon,
                    "direction": "incoming",
                }));
            }
        }

        let json = serde_json::to_string(&links).unwrap_or_else(|_| "[]".into());
        types::SdkResponse {
            success: true,
            error_code: None,
            error_message: None,
            data: Some(json),
        }
    }
}

// ============================================================
// settings::Host — Plugin-scoped key-value settings (Tier 1)
// ============================================================

impl settings::Host for PluginState {
    fn get(&mut self, key: String, default_value: String) -> wasmtime::Result<String> {
        Ok(self
            .settings
            .get(&key)
            .cloned()
            .unwrap_or(default_value))
    }

    fn set(&mut self, key: String, value: String) -> wasmtime::Result<()> {
        self.settings.insert(key, value);
        Ok(())
    }

    fn remove(&mut self, key: String) -> wasmtime::Result<()> {
        self.settings.remove(&key);
        Ok(())
    }
}

// ============================================================
// logger::Host — Structured logging with plugin context (Tier 1)
// ============================================================

impl logger::Host for PluginState {
    fn debug(&mut self, message: String) -> wasmtime::Result<()> {
        debug!(plugin_id = %self.plugin_id, "{}", message);
        Ok(())
    }

    fn info(&mut self, message: String) -> wasmtime::Result<()> {
        info!(plugin_id = %self.plugin_id, "{}", message);
        Ok(())
    }

    fn warn(&mut self, message: String) -> wasmtime::Result<()> {
        warn!(plugin_id = %self.plugin_id, "{}", message);
        Ok(())
    }

    fn error(&mut self, message: String) -> wasmtime::Result<()> {
        error!(plugin_id = %self.plugin_id, "{}", message);
        Ok(())
    }
}

// ============================================================
// navigation::Host — Plugin navigation (Tier 1)
// ============================================================

impl navigation::Host for PluginState {
    fn navigate_to(&mut self, plugin_id: String) -> wasmtime::Result<()> {
        debug!(
            plugin_id = %self.plugin_id,
            target = %plugin_id,
            "Navigate to plugin"
        );
        self.pending_navigation = Some(plugin_id);
        Ok(())
    }

    fn navigate_back(&mut self) -> wasmtime::Result<()> {
        debug!(plugin_id = %self.plugin_id, "Navigate back");
        self.pending_navigation = Some("__back__".into());
        Ok(())
    }
}

// ============================================================
// state-notify::Host — View state change notification (Tier 1)
// ============================================================

impl state_notify::Host for PluginState {
    fn notify_state_changed(&mut self, _json_patch: Option<String>) -> wasmtime::Result<()> {
        self.state_dirty = true;
        Ok(())
    }
}

// ============================================================
// vault::Host — Encrypted vault operations (Tier 2, JIT prompted)
// ============================================================

impl vault::Host for PluginState {
    fn is_initialized(&mut self, _vault_id: String) -> wasmtime::Result<bool> {
        if self.check_permission(Permission::Vault).is_err() {
            return Ok(false);
        }
        Ok(false)
    }

    fn initialize(&mut self, _vault_id: String, _password: String) -> wasmtime::Result<()> {
        if let Err(e) = self.check_permission(Permission::Vault) {
            warn!(plugin_id = %self.plugin_id, "Vault access denied: {}", e);
        }
        Ok(())
    }

    fn unlock(&mut self, _vault_id: String, _password: String) -> wasmtime::Result<()> {
        if let Err(e) = self.check_permission(Permission::Vault) {
            warn!(plugin_id = %self.plugin_id, "Vault access denied: {}", e);
        }
        Ok(())
    }

    fn lock(&mut self, _vault_id: String) -> wasmtime::Result<()> {
        if let Err(e) = self.check_permission(Permission::Vault) {
            warn!(plugin_id = %self.plugin_id, "Vault access denied: {}", e);
        }
        Ok(())
    }

    fn blob_store(
        &mut self,
        _vault_id: String,
        _blob_id: String,
        _data: Vec<u8>,
    ) -> wasmtime::Result<()> {
        if let Err(e) = self.check_permission(Permission::Vault) {
            warn!(plugin_id = %self.plugin_id, "Vault access denied: {}", e);
        }
        Ok(())
    }

    fn blob_read(
        &mut self,
        _vault_id: String,
        _blob_id: String,
    ) -> wasmtime::Result<Vec<u8>> {
        if self.check_permission(Permission::Vault).is_err() {
            return Ok(Vec::new());
        }
        Ok(Vec::new())
    }

    fn blob_delete(&mut self, _vault_id: String, _blob_id: String) -> wasmtime::Result<()> {
        if let Err(e) = self.check_permission(Permission::Vault) {
            warn!(plugin_id = %self.plugin_id, "Vault access denied: {}", e);
        }
        Ok(())
    }
}

// ============================================================
// linking::Host — Cross-plugin item linking (Tier 2, JIT prompted)
// ============================================================

impl linking::Host for PluginState {
    fn search_items(
        &mut self,
        _query: String,
        _max_results: u32,
    ) -> wasmtime::Result<Vec<types::LinkableItem>> {
        if self.check_permission(Permission::Linking).is_err() {
            return Ok(Vec::new());
        }
        Ok(Vec::new())
    }

    fn get_item_by_id(
        &mut self,
        _item_id: String,
    ) -> wasmtime::Result<Option<types::LinkableItem>> {
        if self.check_permission(Permission::Linking).is_err() {
            return Ok(None);
        }
        Ok(None)
    }

    fn get_all_providers(&mut self) -> wasmtime::Result<Vec<types::LinkProviderInfo>> {
        if self.check_permission(Permission::Linking).is_err() {
            return Ok(Vec::new());
        }
        Ok(Vec::new())
    }

    fn query_all(
        &mut self,
        _query: String,
        _max_results: u32,
    ) -> wasmtime::Result<Vec<types::LinkableItem>> {
        if self.check_permission(Permission::Linking).is_err() {
            return Ok(Vec::new());
        }
        Ok(Vec::new())
    }
}

// ============================================================
// dialogs::Host — Dialog prompts (Tier 2, JIT prompted)
// ============================================================

impl dialogs::Host for PluginState {
    fn show_confirmation(
        &mut self,
        _title: String,
        _message: String,
    ) -> wasmtime::Result<bool> {
        if self.check_permission(Permission::Dialogs).is_err() {
            return Ok(false);
        }
        Ok(false)
    }

    fn show_open_file(
        &mut self,
        _title: String,
        _filters: Vec<String>,
    ) -> wasmtime::Result<Option<String>> {
        if self.check_permission(Permission::Dialogs).is_err() {
            return Ok(None);
        }
        Ok(None)
    }
}

// ============================================================
// network::Host — HTTP fetch (Tier 3, install-time permission)
// ============================================================

impl network::Host for PluginState {
    fn fetch_url(
        &mut self,
        url: String,
        method: String,
        headers: Vec<network::HttpHeader>,
        body: Option<Vec<u8>>,
    ) -> wasmtime::Result<Result<network::HttpResponse, String>> {
        if let Err(e) = self.check_permission(Permission::Network) {
            return Ok(Err(format!("network permission denied: {}", e)));
        }

        debug!(
            plugin_id = %self.plugin_id,
            url = %url,
            method = %method,
            "Network fetch"
        );

        let client = match reqwest::blocking::Client::builder()
            .timeout(std::time::Duration::from_secs(30))
            .user_agent("PrivStack/1.0")
            .build()
        {
            Ok(c) => c,
            Err(e) => return Ok(Err(format!("failed to create HTTP client: {}", e))),
        };

        let method = match method.parse::<reqwest::Method>() {
            Ok(m) => m,
            Err(e) => return Ok(Err(format!("invalid HTTP method: {}", e))),
        };

        let mut request = client.request(method, &url);

        for header in &headers {
            request = request.header(&header.name, &header.value);
        }

        if let Some(body_bytes) = body {
            request = request.body(body_bytes);
        }

        let response = match request.send() {
            Ok(r) => r,
            Err(e) => return Ok(Err(format!("HTTP request failed: {}", e))),
        };

        let status = response.status().as_u16();
        let resp_headers: Vec<network::HttpHeader> = response
            .headers()
            .iter()
            .map(|(name, value)| network::HttpHeader {
                name: name.to_string(),
                value: value.to_str().unwrap_or("").to_string(),
            })
            .collect();

        let body_bytes = match response.bytes() {
            Ok(b) => b.to_vec(),
            Err(e) => return Ok(Err(format!("failed to read response body: {}", e))),
        };

        Ok(Ok(network::HttpResponse {
            status,
            headers: resp_headers,
            body: body_bytes,
        }))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::permissions::PermissionSet;
    use crate::sandbox::{PluginSandbox, ResourceLimits};
    use crate::wit_types::*;
    use std::sync::Arc;

    fn test_stores() -> (
        Arc<privstack_storage::EntityStore>,
        Arc<privstack_storage::EventStore>,
    ) {
        let es = privstack_storage::EntityStore::open_in_memory().unwrap();
        let ev = privstack_storage::EventStore::open_in_memory().unwrap();
        (Arc::new(es), Arc::new(ev))
    }

    fn test_metadata() -> WitPluginMetadata {
        WitPluginMetadata {
            id: "host-impl-test".into(),
            name: "Host Impl Test".into(),
            description: "tests".into(),
            version: "0.1.0".into(),
            author: "test".into(),
            icon: None,
            navigation_order: 100,
            category: WitPluginCategory::Utility,
            can_disable: true,
            is_experimental: false,
        }
    }

    fn test_schemas() -> Vec<WitEntitySchema> {
        vec![WitEntitySchema {
            entity_type: "test_note".into(),
            indexed_fields: vec![WitIndexedField {
                field_path: "/title".into(),
                field_type: WitFieldType::Text,
                searchable: true,
                vector_dim: None,
                enum_options: None,
            }],
            merge_strategy: WitMergeStrategy::LwwPerField,
        }]
    }

    fn make_state(perms: PermissionSet) -> PluginSandbox {
        let (es, ev) = test_stores();
        PluginSandbox::new(
            test_metadata(),
            test_schemas(),
            perms,
            ResourceLimits::first_party(),
            es,
            ev,
        )
        .unwrap()
    }

    // ================================================================
    // sdk::Host — send()
    // ================================================================

    #[test]
    fn sdk_send_create_success() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::Create,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: Some(r#"{"title":"hello"}"#.into()),
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(resp.success);
        assert!(resp.data.is_some());
        // Should contain an id
        let data: serde_json::Value = serde_json::from_str(resp.data.as_ref().unwrap()).unwrap();
        assert!(data.get("id").is_some());
    }

    #[test]
    fn sdk_send_create_no_payload() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::Create,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(!resp.success);
        assert_eq!(resp.error_code, Some(400));
        assert!(resp.error_message.unwrap().contains("payload"));
    }

    #[test]
    fn sdk_send_create_invalid_json() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::Create,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: Some("not json{".into()),
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(!resp.success);
        assert_eq!(resp.error_code, Some(400));
        assert!(resp.error_message.unwrap().contains("invalid JSON"));
    }

    #[test]
    fn sdk_send_undeclared_entity_type_returns_403() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::Create,
            entity_type: "forbidden_type".into(),
            entity_id: None,
            payload: Some("{}".into()),
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(!resp.success);
        assert_eq!(resp.error_code, Some(403));
    }

    #[test]
    fn sdk_send_read_no_entity_id() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::Read,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(!resp.success);
        assert_eq!(resp.error_code, Some(400));
        assert!(resp.error_message.unwrap().contains("entity_id"));
    }

    #[test]
    fn sdk_send_read_not_found() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::Read,
            entity_type: "test_note".into(),
            entity_id: Some("nonexistent-id".into()),
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(!resp.success);
        assert_eq!(resp.error_code, Some(404));
    }

    #[test]
    fn sdk_send_create_then_read() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();

        // Create
        let create_msg = types::SdkMessage {
            action: types::SdkAction::Create,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: Some(r#"{"title":"my note"}"#.into()),
            parameters: vec![],
            source: None,
        };
        let create_resp = sdk::Host::send(state, create_msg).unwrap();
        assert!(create_resp.success);
        let data: serde_json::Value =
            serde_json::from_str(create_resp.data.as_ref().unwrap()).unwrap();
        let id = data["id"].as_str().unwrap().to_string();

        // Read
        let read_msg = types::SdkMessage {
            action: types::SdkAction::Read,
            entity_type: "test_note".into(),
            entity_id: Some(id),
            payload: None,
            parameters: vec![],
            source: None,
        };
        let read_resp = sdk::Host::send(state, read_msg).unwrap();
        assert!(read_resp.success);
        assert!(read_resp.data.is_some());
    }

    #[test]
    fn sdk_send_update_no_entity_id() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::Update,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: Some("{}".into()),
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(!resp.success);
        assert_eq!(resp.error_code, Some(400));
        assert!(resp.error_message.unwrap().contains("entity_id"));
    }

    #[test]
    fn sdk_send_update_no_payload() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::Update,
            entity_type: "test_note".into(),
            entity_id: Some("some-id".into()),
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(!resp.success);
        assert_eq!(resp.error_code, Some(400));
        assert!(resp.error_message.unwrap().contains("payload"));
    }

    #[test]
    fn sdk_send_update_invalid_json() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::Update,
            entity_type: "test_note".into(),
            entity_id: Some("some-id".into()),
            payload: Some("bad json".into()),
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(!resp.success);
        assert_eq!(resp.error_code, Some(400));
    }

    #[test]
    fn sdk_send_update_success() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();

        // Create first
        let create_msg = types::SdkMessage {
            action: types::SdkAction::Create,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: Some(r#"{"title":"original"}"#.into()),
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, create_msg).unwrap();
        let data: serde_json::Value = serde_json::from_str(resp.data.as_ref().unwrap()).unwrap();
        let id = data["id"].as_str().unwrap().to_string();

        // Update
        let update_msg = types::SdkMessage {
            action: types::SdkAction::Update,
            entity_type: "test_note".into(),
            entity_id: Some(id),
            payload: Some(r#"{"title":"updated"}"#.into()),
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, update_msg).unwrap();
        assert!(resp.success);
    }

    #[test]
    fn sdk_send_update_preserves_existing_fields() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();

        // Create entity with multiple fields
        let create_msg = types::SdkMessage {
            action: types::SdkAction::Create,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: Some(r#"{"title":"report.pdf","size":1024,"mime_type":"application/pdf"}"#.into()),
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, create_msg).unwrap();
        assert!(resp.success, "create failed: {:?}", resp.error_message);
        let data: serde_json::Value = serde_json::from_str(resp.data.as_ref().unwrap()).unwrap();
        let id = data["id"].as_str().unwrap().to_string();

        // Partial update — only change folder_id (should preserve title, size, mime_type)
        let update_msg = types::SdkMessage {
            action: types::SdkAction::Update,
            entity_type: "test_note".into(),
            entity_id: Some(id.clone()),
            payload: Some(r#"{"folder_id":"folder-123"}"#.into()),
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, update_msg).unwrap();
        assert!(resp.success, "update failed: {:?}", resp.error_message);

        // Read back and verify all original fields are preserved
        let read_msg = types::SdkMessage {
            action: types::SdkAction::Read,
            entity_type: "test_note".into(),
            entity_id: Some(id),
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, read_msg).unwrap();
        assert!(resp.success);
        let entity: serde_json::Value = serde_json::from_str(resp.data.as_ref().unwrap()).unwrap();
        let data = &entity["data"];
        assert_eq!(data["title"], "report.pdf");
        assert_eq!(data["size"], 1024);
        assert_eq!(data["mime_type"], "application/pdf");
        assert_eq!(data["folder_id"], "folder-123");
    }

    #[test]
    fn sdk_send_delete_no_entity_id() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::Delete,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(!resp.success);
        assert_eq!(resp.error_code, Some(400));
    }

    #[test]
    fn sdk_send_delete_success() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();

        // Create first
        let create_msg = types::SdkMessage {
            action: types::SdkAction::Create,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: Some(r#"{"title":"to delete"}"#.into()),
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, create_msg).unwrap();
        let data: serde_json::Value = serde_json::from_str(resp.data.as_ref().unwrap()).unwrap();
        let id = data["id"].as_str().unwrap().to_string();

        // Delete
        let del_msg = types::SdkMessage {
            action: types::SdkAction::Delete,
            entity_type: "test_note".into(),
            entity_id: Some(id),
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, del_msg).unwrap();
        assert!(resp.success);
    }

    #[test]
    fn sdk_send_list_all() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::ListAll,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(resp.success);
        assert!(resp.data.is_some());
    }

    #[test]
    fn sdk_send_query_with_limit_param() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::Query,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: None,
            parameters: vec![
                ("limit".into(), "10".into()),
                ("status".into(), "active".into()),
            ],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        // query_entities may fail if no schema is registered in the store;
        // we still exercise the parameter-parsing path either way
        assert!(resp.error_code.is_none() || resp.error_code == Some(500));
    }

    #[test]
    fn sdk_send_query_without_limit() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::Query,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        // Same as above — exercises the default-limit code path
        assert!(resp.error_code.is_none() || resp.error_code == Some(500));
    }

    #[test]
    fn sdk_send_trash_no_entity_id() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::Trash,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(!resp.success);
        assert_eq!(resp.error_code, Some(400));
    }

    #[test]
    fn sdk_send_trash_success() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();

        // Create
        let create_msg = types::SdkMessage {
            action: types::SdkAction::Create,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: Some(r#"{"title":"to trash"}"#.into()),
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, create_msg).unwrap();
        let data: serde_json::Value = serde_json::from_str(resp.data.as_ref().unwrap()).unwrap();
        let id = data["id"].as_str().unwrap().to_string();

        // Trash
        let trash_msg = types::SdkMessage {
            action: types::SdkAction::Trash,
            entity_type: "test_note".into(),
            entity_id: Some(id),
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, trash_msg).unwrap();
        assert!(resp.success);
    }

    #[test]
    fn sdk_send_restore_no_entity_id() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::Restore,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(!resp.success);
        assert_eq!(resp.error_code, Some(400));
    }

    #[test]
    fn sdk_send_restore_success() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();

        // Create
        let create_msg = types::SdkMessage {
            action: types::SdkAction::Create,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: Some(r#"{"title":"to restore"}"#.into()),
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, create_msg).unwrap();
        let data: serde_json::Value = serde_json::from_str(resp.data.as_ref().unwrap()).unwrap();
        let id = data["id"].as_str().unwrap().to_string();

        // Trash then restore
        let trash_msg = types::SdkMessage {
            action: types::SdkAction::Trash,
            entity_type: "test_note".into(),
            entity_id: Some(id.clone()),
            payload: None,
            parameters: vec![],
            source: None,
        };
        sdk::Host::send(state, trash_msg).unwrap();

        let restore_msg = types::SdkMessage {
            action: types::SdkAction::Restore,
            entity_type: "test_note".into(),
            entity_id: Some(id),
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, restore_msg).unwrap();
        assert!(resp.success);
    }

    // ================================================================
    // sdk::Host — search()
    // ================================================================

    #[test]
    fn sdk_search_no_filter() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let resp = sdk::Host::search(state, "hello".into(), None, 10).unwrap();
        assert!(resp.success);
    }

    #[test]
    fn sdk_search_with_valid_type_filter() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let resp =
            sdk::Host::search(state, "hello".into(), Some(vec!["test_note".into()]), 10).unwrap();
        assert!(resp.success);
    }

    #[test]
    fn sdk_search_with_undeclared_type_filter() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let resp =
            sdk::Host::search(state, "hello".into(), Some(vec!["forbidden".into()]), 10).unwrap();
        assert!(!resp.success);
        assert_eq!(resp.error_code, Some(403));
    }

    // ================================================================
    // settings::Host
    // ================================================================

    #[test]
    fn settings_get_default() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let val = settings::Host::get(state, "missing".into(), "fallback".into()).unwrap();
        assert_eq!(val, "fallback");
    }

    #[test]
    fn settings_set_and_get() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        settings::Host::set(state, "theme".into(), "dark".into()).unwrap();
        let val = settings::Host::get(state, "theme".into(), "light".into()).unwrap();
        assert_eq!(val, "dark");
    }

    #[test]
    fn settings_remove() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        settings::Host::set(state, "key".into(), "val".into()).unwrap();
        settings::Host::remove(state, "key".into()).unwrap();
        let val = settings::Host::get(state, "key".into(), "default".into()).unwrap();
        assert_eq!(val, "default");
    }

    // ================================================================
    // logger::Host
    // ================================================================

    #[test]
    fn logger_debug() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        logger::Host::debug(state, "test debug message".into()).unwrap();
    }

    #[test]
    fn logger_info() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        logger::Host::info(state, "test info message".into()).unwrap();
    }

    #[test]
    fn logger_warn() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        logger::Host::warn(state, "test warn message".into()).unwrap();
    }

    #[test]
    fn logger_error() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        logger::Host::error(state, "test error message".into()).unwrap();
    }

    // ================================================================
    // navigation::Host
    // ================================================================

    #[test]
    fn navigate_to_sets_pending() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        navigation::Host::navigate_to(state, "target.plugin".into()).unwrap();
        assert_eq!(state.pending_navigation.as_deref(), Some("target.plugin"));
    }

    #[test]
    fn navigate_back_sets_back_marker() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        navigation::Host::navigate_back(state).unwrap();
        assert_eq!(state.pending_navigation.as_deref(), Some("__back__"));
    }

    // ================================================================
    // state_notify::Host
    // ================================================================

    #[test]
    fn notify_state_changed_sets_dirty() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        assert!(!state.state_dirty);
        state_notify::Host::notify_state_changed(state, None).unwrap();
        assert!(state.state_dirty);
    }

    #[test]
    fn notify_state_changed_with_patch() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        state_notify::Host::notify_state_changed(state, Some(r#"{"op":"replace"}"#.into()))
            .unwrap();
        assert!(state.state_dirty);
    }

    // ================================================================
    // vault::Host — all methods with and without permission
    // ================================================================

    #[test]
    fn vault_is_initialized_denied() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let result = vault::Host::is_initialized(state, "v1".into()).unwrap();
        assert!(!result);
    }

    #[test]
    fn vault_is_initialized_granted() {
        let mut sandbox = make_state(PermissionSet::all_granted());
        let state = sandbox.state_mut();
        let result = vault::Host::is_initialized(state, "v1".into()).unwrap();
        // Still false (stub), but permission check passes
        assert!(!result);
    }

    #[test]
    fn vault_initialize_denied() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        vault::Host::initialize(state, "v1".into(), "pw".into()).unwrap();
    }

    #[test]
    fn vault_initialize_granted() {
        let mut sandbox = make_state(PermissionSet::all_granted());
        let state = sandbox.state_mut();
        vault::Host::initialize(state, "v1".into(), "pw".into()).unwrap();
    }

    #[test]
    fn vault_unlock_denied() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        vault::Host::unlock(state, "v1".into(), "pw".into()).unwrap();
    }

    #[test]
    fn vault_unlock_granted() {
        let mut sandbox = make_state(PermissionSet::all_granted());
        let state = sandbox.state_mut();
        vault::Host::unlock(state, "v1".into(), "pw".into()).unwrap();
    }

    #[test]
    fn vault_lock_denied() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        vault::Host::lock(state, "v1".into()).unwrap();
    }

    #[test]
    fn vault_lock_granted() {
        let mut sandbox = make_state(PermissionSet::all_granted());
        let state = sandbox.state_mut();
        vault::Host::lock(state, "v1".into()).unwrap();
    }

    #[test]
    fn vault_blob_store_denied() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        vault::Host::blob_store(state, "v1".into(), "b1".into(), vec![1, 2, 3]).unwrap();
    }

    #[test]
    fn vault_blob_store_granted() {
        let mut sandbox = make_state(PermissionSet::all_granted());
        let state = sandbox.state_mut();
        vault::Host::blob_store(state, "v1".into(), "b1".into(), vec![1, 2, 3]).unwrap();
    }

    #[test]
    fn vault_blob_read_denied() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let result = vault::Host::blob_read(state, "v1".into(), "b1".into()).unwrap();
        assert!(result.is_empty());
    }

    #[test]
    fn vault_blob_read_granted() {
        let mut sandbox = make_state(PermissionSet::all_granted());
        let state = sandbox.state_mut();
        let result = vault::Host::blob_read(state, "v1".into(), "b1".into()).unwrap();
        assert!(result.is_empty());
    }

    #[test]
    fn vault_blob_delete_denied() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        vault::Host::blob_delete(state, "v1".into(), "b1".into()).unwrap();
    }

    #[test]
    fn vault_blob_delete_granted() {
        let mut sandbox = make_state(PermissionSet::all_granted());
        let state = sandbox.state_mut();
        vault::Host::blob_delete(state, "v1".into(), "b1".into()).unwrap();
    }

    // ================================================================
    // linking::Host
    // ================================================================

    #[test]
    fn linking_search_items_denied() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let result = linking::Host::search_items(state, "query".into(), 10).unwrap();
        assert!(result.is_empty());
    }

    #[test]
    fn linking_search_items_granted() {
        let mut sandbox = make_state(PermissionSet::all_granted());
        let state = sandbox.state_mut();
        let result = linking::Host::search_items(state, "query".into(), 10).unwrap();
        assert!(result.is_empty());
    }

    #[test]
    fn linking_get_item_by_id_denied() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let result = linking::Host::get_item_by_id(state, "id1".into()).unwrap();
        assert!(result.is_none());
    }

    #[test]
    fn linking_get_item_by_id_granted() {
        let mut sandbox = make_state(PermissionSet::all_granted());
        let state = sandbox.state_mut();
        let result = linking::Host::get_item_by_id(state, "id1".into()).unwrap();
        assert!(result.is_none());
    }

    #[test]
    fn linking_get_all_providers_denied() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let result = linking::Host::get_all_providers(state).unwrap();
        assert!(result.is_empty());
    }

    #[test]
    fn linking_get_all_providers_granted() {
        let mut sandbox = make_state(PermissionSet::all_granted());
        let state = sandbox.state_mut();
        let result = linking::Host::get_all_providers(state).unwrap();
        assert!(result.is_empty());
    }

    #[test]
    fn linking_query_all_denied() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let result = linking::Host::query_all(state, "query".into(), 5).unwrap();
        assert!(result.is_empty());
    }

    #[test]
    fn linking_query_all_granted() {
        let mut sandbox = make_state(PermissionSet::all_granted());
        let state = sandbox.state_mut();
        let result = linking::Host::query_all(state, "query".into(), 5).unwrap();
        assert!(result.is_empty());
    }

    // ================================================================
    // dialogs::Host
    // ================================================================

    #[test]
    fn dialogs_show_confirmation_denied() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let result =
            dialogs::Host::show_confirmation(state, "title".into(), "msg".into()).unwrap();
        assert!(!result);
    }

    #[test]
    fn dialogs_show_confirmation_granted() {
        let mut sandbox = make_state(PermissionSet::all_granted());
        let state = sandbox.state_mut();
        let result =
            dialogs::Host::show_confirmation(state, "title".into(), "msg".into()).unwrap();
        assert!(!result); // stub returns false
    }

    #[test]
    fn dialogs_show_open_file_denied() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let result =
            dialogs::Host::show_open_file(state, "Open".into(), vec!["*.txt".into()]).unwrap();
        assert!(result.is_none());
    }

    #[test]
    fn dialogs_show_open_file_granted() {
        let mut sandbox = make_state(PermissionSet::all_granted());
        let state = sandbox.state_mut();
        let result =
            dialogs::Host::show_open_file(state, "Open".into(), vec!["*.txt".into()]).unwrap();
        assert!(result.is_none()); // stub returns None
    }

    // ================================================================
    // network::Host — permission denied path only (avoid real HTTP)
    // ================================================================

    #[test]
    fn network_fetch_url_denied() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let result = network::Host::fetch_url(
            state,
            "https://example.com".into(),
            "GET".into(),
            vec![],
            None,
        )
        .unwrap();
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("permission denied"));
    }

    #[test]
    fn network_fetch_url_bad_url_returns_error() {
        let mut sandbox = make_state(PermissionSet::all_granted());
        let state = sandbox.state_mut();
        // Use an unreachable URL to exercise the request-send error path
        let result = network::Host::fetch_url(
            state,
            "http://127.0.0.1:1".into(),
            "GET".into(),
            vec![],
            None,
        )
        .unwrap();
        assert!(result.is_err());
        assert!(result.unwrap_err().contains("HTTP request failed"));
    }

    #[test]
    fn network_fetch_url_with_headers_and_body() {
        let mut sandbox = make_state(PermissionSet::all_granted());
        let state = sandbox.state_mut();
        let result = network::Host::fetch_url(
            state,
            "http://127.0.0.1:1".into(),
            "POST".into(),
            vec![network::HttpHeader {
                name: "Content-Type".into(),
                value: "application/json".into(),
            }],
            Some(b"{}".to_vec()),
        )
        .unwrap();
        // Will fail to connect, but exercises headers/body paths
        assert!(result.is_err());
    }

    // ================================================================
    // Unimplemented action variant
    // ================================================================

    #[test]
    fn sdk_send_link_missing_entity_id() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::Link,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(!resp.success);
        assert_eq!(resp.error_code, Some(400));
    }

    #[test]
    fn sdk_send_link_success() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();

        // Create two entities first
        let create1 = types::SdkMessage {
            action: types::SdkAction::Create,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: Some(r#"{"title":"Source"}"#.into()),
            parameters: vec![],
            source: None,
        };
        let resp1 = sdk::Host::send(state, create1).unwrap();
        assert!(resp1.success);
        let id1: serde_json::Value = serde_json::from_str(resp1.data.as_deref().unwrap()).unwrap();
        let source_id = id1["id"].as_str().unwrap().to_string();

        let create2 = types::SdkMessage {
            action: types::SdkAction::Create,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: Some(r#"{"title":"Target"}"#.into()),
            parameters: vec![],
            source: None,
        };
        let resp2 = sdk::Host::send(state, create2).unwrap();
        assert!(resp2.success);
        let id2: serde_json::Value = serde_json::from_str(resp2.data.as_deref().unwrap()).unwrap();
        let target_id = id2["id"].as_str().unwrap().to_string();

        // Create link
        let link_msg = types::SdkMessage {
            action: types::SdkAction::Link,
            entity_type: "test_note".into(),
            entity_id: Some(source_id.clone()),
            payload: Some(format!(r#"{{"target_type":"test_note","target_id":"{}"}}"#, target_id)),
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, link_msg).unwrap();
        assert!(resp.success);

        // Verify via get-links
        let get_msg = types::SdkMessage {
            action: types::SdkAction::GetLinks,
            entity_type: "test_note".into(),
            entity_id: Some(source_id.clone()),
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, get_msg).unwrap();
        assert!(resp.success);
        let links: Vec<serde_json::Value> = serde_json::from_str(resp.data.as_deref().unwrap()).unwrap();
        assert!(!links.is_empty());
    }

    #[test]
    fn sdk_send_unlink_missing_entity_id() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::Unlink,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(!resp.success);
        assert_eq!(resp.error_code, Some(400));
    }

    #[test]
    fn sdk_send_get_links_missing_entity_id() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::GetLinks,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(!resp.success);
        assert_eq!(resp.error_code, Some(400));
    }

    #[test]
    fn sdk_send_get_links_empty() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::GetLinks,
            entity_type: "test_note".into(),
            entity_id: Some("nonexistent".into()),
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(resp.success);
        let links: Vec<serde_json::Value> = serde_json::from_str(resp.data.as_deref().unwrap()).unwrap();
        assert!(links.is_empty());
    }

    #[test]
    fn sdk_send_unimplemented_action_semantic_search() {
        let mut sandbox = make_state(PermissionSet::default_first_party());
        let state = sandbox.state_mut();
        let msg = types::SdkMessage {
            action: types::SdkAction::SemanticSearch,
            entity_type: "test_note".into(),
            entity_id: None,
            payload: None,
            parameters: vec![],
            source: None,
        };
        let resp = sdk::Host::send(state, msg).unwrap();
        assert!(!resp.success);
        assert_eq!(resp.error_code, Some(501));
    }
}
